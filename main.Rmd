---
title: "Financial Cycles in China"
output:
  html_document: default
  pdf_document: 
    keep_tex: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r load, include=FALSE}
source("ceic.R")
source("filter.R")
library(kableExtra)

# Load: China Key Indicators Monthly
cki_m <- ceic_load("CKI_M.m")

# Load: China Key Indicators Quarterly
cki_q <- ceic_load("CKI_Q.m")
```


```{r, include=FALSE}
monthly_series <- list(
  CPI = "5716201",    # CPI MoM
  R007 = "7061001",   # Interbank 7-day repo rate
  House = "4006901",   # Commodity Bldg Selling Price: YTD Average
  AFRE = "365867277"  # Aggregate Financing to the Real Economy
)

data_m <- cki_m$fetch(
  seriesId = as.character(monthly_series), 
  rename_cols = names(monthly_series)
  ) %>%
  # accumulate MoM difference to index
  mutate(CPI = CPI - 100) %>%
  mutate(CPI = cumsum(CPI) + 100) %>%
  # convert monthly data to quarterly
  condense_period(
    .date_var = date, 
    .period = "quarter", 
    .side = "end"
  ) 
```


```{r, include=FALSE}
quarterly_series <- list(
  GDP = "369703417", 
  Credit = "371938917"  # Credit to Non-financial Sector
)

data_q <-  cki_q$fetch(
  seriesId = as.character(quarterly_series), 
  rename_cols = names(quarterly_series)
  ) %>%
  # calculate credit to GDP ratio
  mutate(`Credit/GDP` = Credit/GDP)
```

"Total credit" comprises financing from all sources, including domestic banks, other domestic financial corporations, non-financial corporations and non-residents.
The financial instruments covered comprise currency and deposits, loans and debt securities. 
Debt securities include bonds and short-term papers; equities, insurance, pension funds are not included.
The correlation between BIS credit and AFRE after 2014 is 0.9944.
Therefore, I use only total credit for consistency.

```{r, include=FALSE}
tmp <- full_join(data_m, data_q, by = "date") %>%
  select(date, Credit, AFRE) %>%
  filter_by_time(
    date, 
    .start_date = "2014-03", 
    .end_date = "2019-12"
  ) 
cor(tmp$Credit, tmp$AFRE) # 0.994411
```

The data range is from 1999. First due to data availability; Secondly, China took a major reform in the housing market in July 1998, since when housing properties can be freely traded in the market. 

```{r, results='hide'}
# combine all data: un-adjusted time series 
data <- 
  full_join(data_m, data_q, by = "date") %>%
  select(date, GDP, CPI, House, Credit, `Credit/GDP`, R007) %>% 
  filter_by_time(date, .start_date = "1999-03", .end_date = "2019-12") 

# plot seasonally-adjusted time series
data %>%
  pivot_longer(2:7, names_to = "indicator", values_to = "value") %>%
  group_by(indicator) %>%
  mutate(value_sa = x11_adjust(value, date) %$% final) %>%
  ggplot(aes(x = date, y = value_sa)) +
  facet_wrap(~indicator, scales = "free_y") + 
  geom_line() + labs(x = NULL, y = NULL)
```


```{r spectrum, include=FALSE}
plot_spectrum <- function(x, log=FALSE) {
  name <- quo_name(enquo(x))
  sp <- spectrum(x, plot=FALSE)
  tibble(freq = sp$freq, spec = sp$spec) %>%
    mutate(period = 1/freq) %>%
    ggplot(aes(freq, spec)) +
    # scale_y_log10() +
    geom_line() + 
    labs(y = name)
}
plot_spectrum(data$GDP)
```

Spectrum analysis suggests GDP series has a mild 4-year cycle, CPI a 4-year cycle, 
property price 3-4 years cycle, credit a strong 4-5 years cycle and a mild 2 year cycle,
interest rate a strong 3.5 years cycle.

```{r, results='hide'}

# extract cyclical components from the time series
data_cyl <- data %>%
  # log before or after seasonal adjustment are almost identical
  mutate_at(vars(GDP, Credit, House), ~log(.)) %>%
  mutate_at(vars(-date), ~ x11_adjust(., index = date) %$% final) %>%
  mutate_at(vars(-date), ~ hp_filter(., .lambda = 1600) %$% cycle)

# standarize the cycles by standard deviation (mean = 0)
data_s <- data_cyl %>%
  mutate_at(vars(-date), ~ ./sd(.))

# transformed data
# data_s %>% skimr::skim()
```

```{r}
# plot cyclical components of the series
data_s %>%
  pivot_longer(2:7, names_to = "indicator", values_to = "value") %>%
  ggplot(aes(x = date, y = value)) + 
  facet_wrap(~indicator) + 
  geom_line() + 
  labs(x = NULL, y = NULL)
```


## Correlation between series

```{r, message=FALSE}
data_s %>% GGally::ggpairs(columns = 2:7)
```

## Identifying turning point

```{r}
# Identify turning point using Harding and Pagan algorithm
# The medium-term window has 9 quarters
#  - Y_t is the peak if it is the maximum within the window
#  - Y_t is the trough if it is the minimum within the window
data_t <- data_s %>%
  pivot_longer(2:7, names_to = "indicator", values_to = "value") %>%
  group_by(indicator) %>%
  mutate(peak = slide_dbl(
    value,  
    function(x) {
      mid <- (length(x) + 1) / 2
      if (which.max(x) == mid) x[mid]
      else NA
    },
    .before = 4, .after = 4, .complete = F)
  ) %>%
  mutate(trough = slide_dbl(
    value,  
    function(x) {
      mid <- (length(x) + 1) / 2
      if (which.min(x) == mid) x[mid]
      else NA
    },
    .before = 4, .after = 4, .complete = F)
  ) %>%
  arrange(.by_group = T)
```


```{r}
# this function is used to count the number of cycles
count_nonNA <- (function() {
  # counter inside closure
  .counter <- 0L 
  # for each group, reset the counter
  .group <- 'default'
  # return this function
  function(value, group = 'default') {
    if (group != .group) {
      .group <<- group
      .counter <<- 0L
    }
    if (!is.na(value)) {
      .counter <<- .counter + 1L
    }
    return(.counter)
  }
})()

# compute peak/trough cycles: periods between two peaks (or troughs)
# each non-NA value in `peak` or `trough` indicates 
# the start or end of a cycle
data_t %<>%
  group_by(indicator) %>%
  mutate(peak_cycle= map2_int(peak, indicator, count_nonNA)) %>%
  mutate(trough_cycle = map2_int(trough, indicator, count_nonNA)) 
```

```{r}
# We restrict peaks and troughs must appear alternately, i.e. 
# - between two peaks, there is only one trough
# - between two troughs, there is only one peak
data_t %<>%
  group_by(indicator, peak_cycle) %>% 
  mutate(trough = (function(x) {
      if (all(is.na(x))) x
      else {
        # if there are non-minimal values within two peaks
        # assign those values to NA
        min_x <- min(x, na.rm = T)
        x %>% map_dbl(~ if_else(. > min_x, NA_real_, .))
      }
    })(trough)
  )  

data_t %<>%
  group_by(indicator, trough_cycle) %>% 
  mutate(peak = (function(x) {
      if (all(is.na(x))) x
      else {
        # if there are non-maximal values within two troughs
        # assign those values to NA
        max_x <- max(x, na.rm = T)
        x %>% map_dbl(~ if_else(. < max_x, NA_real_, .))
      }
    })(peak)
  ) 

# after correcting turning points, recompute peak/trough cycles
data_t %<>%
  group_by(indicator) %>%
  mutate(peak_cycle = map2_int(peak, indicator, count_nonNA)) %>%
  mutate(trough_cycle = map2_int(trough, indicator, count_nonNA)) 
```

```{r, warning=FALSE}
data_t %>%
  ggplot(aes(x=date)) +
  geom_line(aes(y=value)) +
  geom_point(aes(y=peak), shape=24, fill="blue") +
  geom_point(aes(y=trough), shape=21, fill="red") +
  facet_wrap(~indicator) + 
  labs(x=NULL, y=NULL) 
```

```{r}
# merge peaks and troughs together
# each peak-to-trough or trough-to-peak is counted 
data_t %<>%
  group_by(indicator) %>%
  mutate(peak_trough = if_else(!is.na(peak), peak, trough)) %>%
  mutate(peak_trough_cycle = map2_int(peak_trough, indicator, count_nonNA)) 
```


## Concordance index

```{r}
# impute value 1 or 0 to upturn or downturn phases
data_up_down <- data_t %>%
  group_by(indicator, peak_trough_cycle) %>%
  mutate(is_upturn = if_else(
    all(is.na(peak_trough)), 
    NA_real_, 
    # 1 indicate an upturn, 0 indicate a downturn
    if_else(sum(peak_trough, na.rm = T) < 0, 1, 0)
  )) %>%
  ungroup() %>%
  select(date, indicator, is_upturn) %>%
  pivot_wider(names_from = indicator, values_from = is_upturn) %>%
  filter_by_time(date, .start_date = "2000-09") # omit all NA rows
```

```{r, warning=FALSE}
data_up_down %>%
  select(-date) %>%
  map(function(each, others) {
    map_dbl(others, ~ sum(.x*.y + (1-.x)*(1-.y), na.rm = T)/length(.x), each)
  }, data_up_down %>% select(-date)) %>%
  as_tibble(rownames = NA) -> concord
rownames(concord) <- names(concord)

concord %>% 
  rownames_to_column(var = "Variables") %>%
  kbl(digits = 2, caption = "Concordance between variables") %>%
  kable_styling(full_width = F)
```

```{r, message=FALSE}
# calculate the duration (number of quarters) of 
# each contraction or expansion cycle
stat_1 <- data_t %>% 
  group_by(indicator, peak_trough_cycle) %>%
  summarise(n = n(), min_max = sum(peak_trough, na.rm = T)) %>%
  mutate(phase = case_when(
    min_max > 0 ~ "Contraction", 
    min_max < 0 ~ "Expansion"
  )) %>% 
  filter(!is.na(phase)) %>%
  group_by(indicator, phase) %>%
  summarise(duration = mean(n)) 
stat_1
```


```{r, message=FALSE}
# calculate the amplitude of each cycle
# we use non-standardized cyclical series to reflect true order of magnitude
stat_2 <- data_cyl %>% 
  pivot_longer(2:7, names_to = "indicator",values_to = "value") %>%
  left_join(
    data_t %>% select(date, indicator, peak_trough, peak_trough_cycle), 
    by = c("date", "indicator")
  ) %>%
  group_by(indicator, peak_trough_cycle) %>%
  arrange(.by_group = T) %>%
  summarize(
    min_max = sum(peak_trough, na.rm = T),
    # the amplitude means the maximal percentage deviation from the trend
    # since the trend is log transformed 
    amplitude = (max(value) - min(value)) 
  ) %>%
  mutate(phase = case_when(
    min_max > 0 ~ "Contraction", 
    min_max < 0 ~ "Expansion"
  )) %>% 
  mutate(
    amplitude = if_else(
      phase == "Contraction", -amplitude, amplitude)
  ) %>% 
  mutate(
    amplitude = if_else(
      indicator %in% c("GDP", "Credit", "House"), 
      amplitude * 100, amplitude
    )
  ) %>%
  filter(!is.na(phase)) %>%
  group_by(indicator, phase) %>%
  summarise(amplitude = mean(amplitude)) 
```

```{r}

# reshape the table for printing
bind_rows(
  stat_1 %>%
    pivot_wider(names_from = phase, values_from = duration) %>%
    mutate(Variable = "Duration (Q)"),
  stat_2 %>%
    pivot_wider(names_from = phase, values_from = amplitude) %>%
    mutate(
      Variable = if_else(
        indicator %in% c("GDP", "Credit", "House"), 
        "Amplitude (%)", "Amplitude (pp.)"
      )
    )
  ) %>%
  group_by(indicator) %>%
  arrange(.by_group = T) %>%
  mutate(`Full Cycle` = if_else(
    Variable == "Duration (Q)", 
    Contraction + Expansion, 
    NA_real_)
  ) %>%
  select(Indicator = indicator, Variable, everything()) -> stat_3

kbl(stat_3, digits = 2, 
    caption = "Basic features of China's financial cycles") %>%
  collapse_rows(columns = 1) %>%
  kable_styling(full_width = F)
```


