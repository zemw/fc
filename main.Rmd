
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, message = F, warning = F) 
knitr::opts_chunk$set(fig.pos = 'htpb', fig.align = 'center') 
knitr::opts_chunk$set(out.width = '100%', dpi=300) 
knitr::opts_chunk$set(fig.env="figure") 
```

```{r libs, include=FALSE}
library(tidyverse)
library(lubridate)
library(magrittr)
library(readxl)
library(tsibble)
library(slider)
library(xts)
library(timetk)
library(patchwork)
library(rlang)
library(kableExtra)
library(dynlm)
library(broom)
library(lmtest)
library(sandwich)
library(stargazer)
```

```{r plot-setup, include=FALSE}
ggplot2::theme_set(theme_minimal() + theme(
  legend.title = element_blank(), 
  legend.position = "bottom"))
```

# Introduction {#intro}

The Global Financial Crisis has prompted a rethink of the role of finance to the
real economy. Though the view that financial factors generate economic
fluctuations has been along for centuries, the mainstream neoclassical thinking
is that "money is a veil" and financial institutions are just intermediaries
which alters no substance in the real economy.

However, the onset of GFC demonstrated the great disruptions that financial
factors could bring about. It is clear that the relationship between the "Wall
Street" and the "Main Street" is not fully captured by just interest rates -- 
as it is commonly assumed in neoclassical literature.

After the GFC, growing efforts have been devoted to bridge the gap between
finance and real economy. On the theoretical side, notably, Gertler and Kiyotaki
(2011). Empirical literature have focused on capturing the regularities of
financial cycles and how it intereacts with real business cycles
(Claessens, 2011).


# Data and methodology {#data}

```{r, message=FALSE}
data_raw <- 
  read_excel("data/data_raw.xlsx", sheet = 1) %>%
  mutate(date = as_date(date))

# HP filtered cyclical components
data_cyl <- 
  read_csv("data/data_vars.csv") %>%
  mutate(date = yq(date) + months(2)) %>% 
  # multiple by 100 since log difference means 
  # the percent deviation from the trend
  mutate_at(vars(GDP, House, Credit), ~.*100)

# standardize the cycles by standard deviation (mean = 0)
data_cyl_std <- data_cyl %>%
  mutate_at(vars(-date), ~ ./sd(.))

```


## Choice of variables {#indicators}

I choose three indicators to characterize the financial cycles: credit, house
price and credit to GDP ratio. Credit reflects the aggregate claims created by
the financial system, which is a natural choice to represent financial cycles.
Credit is also regarded by some as the single most powerful indicator for
financial crisis [@Schularick2012]. In this paper, I use the Total Credit to
the Non-Financial Sector from the BIS credit statistics. ^[BIS total credit
comprises financing from all sources, including domestic banks, other domestic
financial corporations, non-financial corporations and non-residents. The
financial instruments covered comprise currency and deposits, loans and debt
securities. Debt securities include bonds and short-term papers; equities,
insurance, pension funds are not included. In Chinese literature, the Aggregate
Financing to the Real Economy (AFRE) indicator is more widely used. However, the
AFRE statistics are only available yearly after 2002, and monthly after 2014.
The coverage of BIS total credit and AFRE largely overlapped. The correlation
between BIS total credit and AFRE after 2014 is 0.9944. To preserve consistency
in data, BIS total credit is used throughout in this paper.] To measure how
much credit is "over-expanded" relative to the size of the economy, credit to
GDP ratio is calculated and included as a separate indicator.

House price is another important indicator of financial cycles. House
properties, though being real estate, have many similar characteristics as
financial assets. As the most commonly accepted collateral for credit, house
prices capture the endogenous relationship between entities' net worth,
borrowing constraints, and credit creation. Strong evidence suggests household
leverage (mainly through mortgage loans) influences business cycles through
credit supply channels [@Mian2017]. In this paper, I use the Average Price of
Commercial Residential Buildings from the National Bureau of Statistics as a
measure of house prices. ^[This only includes a portion of the total
residential properties in China, indemnificatory housing and other types of
public-built private-owned housing are not included in this statistics. But
narrowing down to privately traded residential properties is a better choice to
reflect market conditions. In Chinese literature, other indicators, such as
average house price of 70 major cities, are more widely used. However, these
indicators are only available for recent years. The indicator chosen in this
paper traced the house prices back to 1998, the beginning of China's housing
reform. ]

The data are at quarterly frequency, ranging from 1999 to 2019. The data starts
from 1999, firstly due to the data availability; secondly, considering China
took a major reform in the housing market in July 1998 -- since then residential
properties can be freely traded in the market -- the house prices before 1999
have little value for the purpose of this paper. The time series are seasonally
adjusted whenever necessary. ^[Except for GDP, I do not adjust the data for
inflation. For the purpose of studying financial cycles, it is the nominal
values that matter. ]


```{r plot-raw-data, include=F}
# fig.heighht = 3.5
data_raw %>%
  filter(year(date) > 1998) %>%
  pivot_longer(2:7) %>%
  group_by(name) %>%
  ggplot(aes(x = date, y = value)) +
  facet_wrap(~name, scales = "free_y") +
  labs(x = NULL, y = NULL) +
  geom_line() 

data_cyl %>%
  pivot_longer(2:7) %>%
  group_by(name) %>%
  ggplot(aes(x = date, y = value)) +
  facet_wrap(~name, scales = "free_y") +
  labs(x = NULL, y = NULL) +
  geom_line() 
```


## Cycle extraction {#cycle}

There are many methodologies to identify cycles in macroeconomic variables. The
classical method tracks absolute increase or decrease of economic activities.
For example, a recession is identified by two consecutive quarters of declines
of GDP. However, this "classical" business cycle definition is not suitable for
fast-growing economies, in which macroeconomic variables are constantly in
upward movement. For fast-growing economies, the "growth cycle methodology" is
more appropriate, which identifies cycles as fluctuations around a trend. In
this paper, I apply the Hodrick-Prescott (HP) filter to extract the cyclical
components from the time series. ^[The lambda value is set to 1600 for
quarterly data as suggested by @Hodrick1997. There are other methods used for
cycle extraction in the literature. For example, @Mayong2016 applied HP filter
to YoY changes of variables. This method is problematic, because HP filter is
designed to obtain trends by smoothing out short-term fluctuations. Performing
year-to-year difference by default removes the trend. Another popular approach
is to apply Bank-Pass filters such as Christiano-Fitzgerald (CF) filter. This is
the approach adopted by @Drehmann2012 and @Taihui2018. However, CF filter
pre-imposes the length of the cycle to be within a certain band. According to
@Drehmann2012, the short-term cycles are between 1 and 8 years, and mid-term
cycles are between 8 to 30 years. Since China's data is available for merely 20
years, applying the CF filter is unnecessary and bears the risk of losing too
much information. ] Log-transformation is applied to variables that grow
proportionately to their sizes such as GDP, credit and house prices. The
magnitude of the cycles are standardized by their standard deviation.


@Harding2002's (medium-term) turning-point algorithm is then applied to identify
peaks and troughs of the cycles. Specifically, the algorithm involves two steps:
(1) identifying local maxima and minima over a window of 9 quarters; (2)
imposing censoring rules that the minimum length of each phase of upturn or
downturn is 2 quarters; Further, I impose a third restriction: (3) peaks and
troughs must appear alternately, that is there must be one and only one peaks
(troughs) between two troughs (peaks). Figure \ref{fig:cycle-tp} plots the HP
filtered cycles of the variables together with the identified turning points.

```{r}
# Identify turning point using Harding and Pagan algorithm
# The medium-term window has 9 quarters
#  - Y_t is the peak if it is the maximum within the window
#  - Y_t is the trough if it is the minimum within the window
data_peak_trough <- data_cyl %>%
  pivot_longer(2:7, names_to = "indicator", values_to = "value") %>%
  group_by(indicator) %>%
  mutate(peak = slide_dbl(
    value,  
    function(x) {
      mid <- (length(x) + 1) / 2
      if (which.max(x) == mid) x[mid]
      else NA
    },
    .before = 4, .after = 4, .complete = T)
  ) %>%
  mutate(trough = slide_dbl(
    value,  
    function(x) {
      mid <- (length(x) + 1) / 2
      if (which.min(x) == mid) x[mid]
      else NA
    },
    .before = 4, .after = 4, .complete = T)
  ) %>%
  arrange(.by_group = T)
```

```{r}
# this function is used to count the number of cycles
count_nonNA <- (function() {
  # counter inside closure
  .counter <- 0L 
  # for each group, reset the counter
  .group <- 'default'
  # return this function
  function(value, group = 'default') {
    if (group != .group) {
      .group <<- group
      .counter <<- 0L
    }
    if (!is.na(value)) {
      .counter <<- .counter + 1L
    }
    return(.counter)
  }
})()

# compute peak/trough cycles: periods between two peaks (or troughs)
# each non-NA value in `peak` or `trough` indicates 
# the start or end of a cycle
data_peak_trough %<>%
  group_by(indicator) %>%
  mutate(peak_cycle= map2_int(peak, indicator, count_nonNA)) %>%
  mutate(trough_cycle = map2_int(trough, indicator, count_nonNA)) 
```

```{r}
# We restrict peaks and troughs must appear alternately, i.e. 
# - between two peaks, there is only one trough
# - between two troughs, there is only one peak
data_peak_trough %<>%
  group_by(indicator, peak_cycle) %>% 
  mutate(trough = (function(x) {
      if (all(is.na(x))) x
      else {
        # if there are non-minimal values within two peaks
        # assign those values to NA
        min_x <- min(x, na.rm = T)
        x %>% map_dbl(~ if_else(. > min_x, NA_real_, .))
      }
    })(trough)
  )  

data_peak_trough %<>%
  group_by(indicator, trough_cycle) %>% 
  mutate(peak = (function(x) {
      if (all(is.na(x))) x
      else {
        # if there are non-maximal values within two troughs
        # assign those values to NA
        max_x <- max(x, na.rm = T)
        x %>% map_dbl(~ if_else(. < max_x, NA_real_, .))
      }
    })(peak)
  ) 

# after correcting turning points, recompute peak/trough cycles
data_peak_trough %<>%
  group_by(indicator) %>%
  mutate(peak_cycle = map2_int(peak, indicator, count_nonNA)) %>%
  mutate(trough_cycle = map2_int(trough, indicator, count_nonNA)) 
```

```{r}
# this is a trick that generates -1, 1, -1, 1,... sequence
ss_substract <- function(x, y) {
  z <- x - y
  if (sum(z) > 0) 
    z[z==0L] <- -1L
  else if (sum(z) < 0) 
    z[z==0L] <- 1L
  z
}

# merge peaks and troughs together
# each peak-to-trough or trough-to-peak is counted 
data_peak_trough %<>%
  group_by(indicator) %>%
  mutate(peak_trough = if_else(!is.na(peak), peak, trough)) %>%
  # 1 means a upturn phase; -1 means a downturn phase
  mutate(up_down = ss_substract(trough_cycle, peak_cycle)) %>%
  mutate(peak_trough_cycle = (peak_cycle + trough_cycle) * up_down)
```

```{r cycle-tp, fig.cap="Business cycles and turning points"}
# plotting the cycles together with the turning points
data_peak_trough %>%
  ggplot(aes(x=date)) +
  geom_line(aes(y=value)) +
  geom_point(aes(y=peak), shape=24, fill="blue") +
  geom_point(aes(y=trough), shape=21, fill="red") +
  facet_wrap(~indicator, scales = "free_y") + 
  labs(x=NULL, y=NULL) 
```


# Basic features of financial cycles in China {#features}

## Duration and amplitude {#duration}


```{r}
# calculate the duration (number of quarters) of 
# each contraction or expansion cycle
stat_duration <- data_peak_trough %>% 
  group_by(indicator, peak_trough_cycle) %>%
  summarise(n = n()) %>%
  mutate(phase = case_when(
    peak_trough_cycle > 0 ~ "Upturn", 
    peak_trough_cycle < 0 ~ "Downturn"
  )) %>% 
  filter(!is.na(phase)) %>%
  group_by(indicator, phase) %>%
  summarise(duration = mean(n)) 
```

```{r}
# calculate the amplitude of each cycle
# we use non-standardized cyclical series to reflect true order of magnitude
stat_amplitude <- data_cyl %>% 
  pivot_longer(2:7, names_to = "indicator",values_to = "value") %>%
  left_join(
    data_peak_trough %>% select(date, indicator, peak_trough, peak_trough_cycle), 
    by = c("date", "indicator")
  ) %>% 
  group_by(indicator) %>%
  arrange(.by_group = TRUE) %>%
  # creating a leading vector, the number represents the peak or trough \
  # in a upturn or downturn phase
  mutate(peak_trough_1 = dplyr::lead(peak_trough, order_by = date)) %>%
  group_by(indicator, peak_trough_cycle) %>%
  summarize(
    # the amplitude means the maximal percentage deviation from the trend
    # since the trend is log transformed 
    amplitude = sum(peak_trough_1, na.rm=T)
  ) %>%
  mutate(phase = case_when(
    peak_trough_cycle > 0 ~ "Upturn", 
    peak_trough_cycle < 0 ~ "Downturn"
  )) %>% 
  filter(peak_trough_cycle != 0, amplitude != 0) %>%
  group_by(indicator, phase) %>%
  summarise(amplitude = mean(amplitude)) 
```

```{r dur-amp}
# reshape the table for printing
bind_rows(
  # duration table
  stat_duration %>%
    pivot_wider(names_from = phase, values_from = duration) %>%
    mutate(Variable = "Duration (Q)"),
  # amplitude table
  stat_amplitude %>%
    pivot_wider(names_from = phase, values_from = amplitude) %>%
    mutate(
      Variable = if_else(
        indicator %in% c("GDP", "Credit", "House"), 
        "Amplitude (%)", 
        "Amplitude (pp.)"
      )
    )
  ) %>%
  group_by(indicator) %>%
  arrange(.by_group = T) %>%
  mutate(`Full Cycle` = if_else(
    Variable == "Duration (Q)", 
    Upturn + Downturn, 
    NA_real_)
  ) %>%
  select(Indicator = indicator, Variable, everything()) -> stat_dur_amp

options(knitr.kable.NA = '')
kbl(stat_dur_amp, digits = 2, booktabs = T,
    caption = "Basic cyclical features of main variables") %>%
  collapse_rows(columns = 1) %>%
  kable_styling(full_width = F)
```

Based on the identified turning points in Section \ref{cycle-extraction}, I
calculated the duration and amplitude of the cycles for each series (Table
\ref{tab:dur-amp}). The duration of an upturn (downturn) is defined as the
quarters from a trough (peak) to a peak (trough). The amplitude of an upturn
(downturn) is defined as the largest positive (negative) deviation from the
trend.

Table \ref{tab:dur-amp} shows (1) Most variables have full cycles of 10-13
quarters, while GDP and Credit/GDP demonstrate considerable longer cycles that
lasts 18-19 quarters. ^[Spectrum analysis suggests GDP series has a 22-quarter
cycle, CPI a 15-quarter cycle, property price a 22-quarter cycle and
a 12-quarter cycle, credit a 18-quarter cycle and a 12-quarter cycle.] (2) Most
variables exhibit longer quarters of downturn than upturn. An upturn takes an
average of 5-8 quarters, while a downturn generally takes 6-11 quarters. (3) For
GDP and credit, the downturns are more severe than the upturns (more pronounced
amplitude). While for houses, price levels, and interest rates, the amplitude of
troughs are relatively mild compared to peaks. ^[The numbers here demonstrate
drastically different characteristics from financial or business cycles
concluded from developed economies [@Claessens2012;@Borio2014]. In the later
case, financial variables generally have longer cycles than real variables, and
upturns are typically more pronounced in magnitude than downturns. The
difference is partly due to the different methodology adopted in this paper. The
"growth cycle method" is more sensitive to downturns than the "classical
method". Institutional factors also affect the behavior of macroeconomic
variables. For example, strong counter-cyclical fiscal policy is usually adopted
in China during downturns. These factors make real GDP more stable than
financial variables. The results here are consistent with conclusions from
Chinese literature [@Yinan2016; @Taihui2018]. ]

```{r spectrum-analysis, include=FALSE}
gg_spec <- function(x, log=FALSE) {
  sp <- spectrum(x, plot=FALSE)
  tb <- tibble(freq = sp$freq, spec = sp$spec) %>%
    mutate(period = 1/freq)
  tb
}
# gg_spec(data_raw$R007)
# ggplot(.Last.value, aes(x=freq, y=spec)) + geom_line()
```


## Correlation and concordance {#correlation}

Figure \ref{fig:corr} shows the correlation between the series. GDP and CPI
have a strong positive correlation, and both of them are positively correlated
with the interest rate. Credit is negatively correlated with the interest rate,
and hence negatively correlated with GDP and CPI. House prices do not exhibit
strong correlations with any other series.

```{r corr, fig.cap="Correlation between series", message=FALSE}
data_cyl_std %>% GGally::ggpairs(columns = 2:7)
```

To further shed some light on the concordance of the cycles of different series,
I calculated the concordance score between the variables as did by
@Drehmann2012. Concordance measures the percentage of time for which two series
are in the same phase (upturn or downturn). Specifically, the concordance scroe
is defined as

$$ \rho_{XY} = \frac{1}{T} \sum_{t=1}^{T} [\rho_t^{X}\rho_t^{Y} + (1-\rho_t^{X})(1-\rho_t^{Y})]$$

where $\rho_t^{X} = \begin{cases}0, \text{if X is in downturn} \\1, \text{if X is in upturn} \end{cases}$,
$\rho_t^{Y} = \begin{cases}0, \text{if Y is in downturn} \\1, \text{if Y is in upturn} \end{cases}$.


```{r}
# impute value 1 or 0 to upturn or downturn phases
stat_updown <- data_peak_trough %>%
  group_by(indicator, peak_trough_cycle) %>%
  # 1 indicate an upturn, 0 indicate a downturn
  mutate(is_upturn = if_else(up_down > 0, 1, 0)) %>%
  ungroup() %>%
  select(date, indicator, is_upturn) %>%
  pivot_wider(names_from = indicator, values_from = is_upturn) 
```

```{r cord, warning=FALSE}
stat_updown %>%
  select(-date) %>%
  map(function(each, others) {
    map_dbl(others, ~ sum(.x*.y + (1-.x)*(1-.y), na.rm = T)/length(.x), each)
  }, stat_updown %>% select(-date)) %>%
  as_tibble(rownames = NA) -> stat_concord
rownames(stat_concord) <- names(stat_concord)

stat_concord %>% 
  rownames_to_column(var = "Variables") %>%
  kbl(digits = 2, booktabs = T, caption = "Concordance between variables") %>%
  kable_styling(full_width = F)
```


The concordance scores (Table \ref{tab:cord}) shows that GDP and CPI have 68%
of their cycles overlapped. Interest rate cycles overlap 67% of GDP cycles, 64%
of credit cycles, and 62% of house price cycles. Credit cycles have relatively
low concordance with real variables, 55% with GDP, and 39% with CPI. House
prices have almost half of the cycles overlapped with all other variables,
though the concordance with interest rate is slightly higher up to 62%.


## Event study around financial cycle peaks and troughs {#event}

It is of particular interest how macroeconomic variables behave after 
a financial cycle indicator peaks or troughs. 
This section conducts an event study based on the peaks and troughs 
identified in Section \ref{cycle}.

Figure \ref{fig:event-study-2} traces the average real GDP gaps 
after a peak or trough in each of the three financial cycle indicators. 
For comparison, Figure \ref{fig:event-study-2} also shows a reference trend 
after a "placebo" event (the average of 1000 random draws of 6 consecutive 
quarters from the dataset). 
In every scenario, the dynamics of real GDP is visibly different from the 
"placebo" reference. 

Several observations are worth to remark. 
(1) Real GDP on average peaks in 4 quarters after a credit cycle peaks, 
and falls below the trend in 6 quarters; 
while after a credit cycle troughs, real GDP troughs in 2 quarters, 
and moves above the trend in 5 quarters. 
(2) The real economy responds more promptly to real estate cycles. 
Real GDP peaks in just 2 quarters after real estate price peaks, 
and troughs almost simultaneously as real estate price troughs. 
(3) Real GDP has a sluggish response to overall leverage cycles. 
Real GDP peaks in 4-6 quarters after a leverage cycle peaks, and bottoms 
in 2-4 quarters after a leverage cycle troughs; 
however, the real GDP never reverses to the other side of the growth trend 
after it peaks or troughs, which signals a less consequential response 
of the real economy. 


```{r data-preparation}
# preparing leads and lags data for event study
data_leads_lags <- ungroup(data_peak_trough) %>% 
  mutate(name = case_when(
    indicator == "Credit/GDP" ~ "Leverage", 
    indicator == "R007" ~ "IR", 
    TRUE ~ indicator)) %>% 
  mutate(peak = if_else(is.na(peak), 0L, 1L)) %>% 
  mutate(trough = if_else(is.na(trough), 0L, 1L)) %>% 
  select(date, name, value, peak, trough) 
# generate leads and lags
# todo: is there a way to automate this?
data_leads_lags %<>%  # assign back to tibble
  group_by(name) %>% 
  mutate(
    L0 = dplyr::lag(value, 0L),
    L1 = dplyr::lag(value, 1L), 
    L2 = dplyr::lag(value, 2L),
    L3 = dplyr::lag(value, 3L),
    L4 = dplyr::lag(value, 4L),
    L5 = dplyr::lag(value, 5L),
    L6 = dplyr::lag(value, 6L),
    H1 = dplyr::lead(value, 1L),
    H2 = dplyr::lead(value, 2L),
    H3 = dplyr::lead(value, 3L),
    H4 = dplyr::lead(value, 4L),
    H5 = dplyr::lead(value, 5L),
    H6 = dplyr::lead(value, 6L)
  ) %>% 
  select(!value) %>% 
  pivot_wider(values_from = c(L0:L6, H1:H6, peak, trough))
```

```{r event-study-helpers}
# calculate summary statistics around a time event
# condition: condition for the event (in expression)
# var_names: vector of variable names to summarize
summarize_around_event <- function(data, condition, var_names) {
  # convert H1, L1, ... to 1, -1, ...
  lags_as_integer <- function(name) {
    if_else(str_starts(name, "L"), 
            gsub("L", "-", name), 
            gsub("H", "", name)
            ) %>% as.integer
    }
  # returns a dataframe with columns:
  # - index: leads and lags around the event
  # - columns: mean of variables of interest
  data %>% 
    filter({{ condition }}) %>% 
    select(contains(var_names)) %>% 
    select(!contains(c("peak", "trough"))) %>% 
    pivot_longer(everything()) %>% 
    separate(name, c("index", "name"), remove = T) %>% 
    mutate(index = lags_as_integer(index)) %>% 
    group_by(name, index) %>% 
    # todo: is it okay to remove NAs?
    summarise(value = mean(value, na.rm = T)) %>%  
    pivot_wider() 
}

# generate 'placebo' event (no event actually happened) used for reference
# e.g. randomly draw a sample of 13 consecutive quarters for 1000 times
#      and calculate the mean. 
placebo_event <- function(data, var_names, random_draws = 1000) {
  data %>% 
    sample_n(random_draws, replace = T) %>% 
    summarize_around_event(., TRUE, var_names) %>% 
    rename_with(~str_c(., " placebo"), !index)
}

# plot the mean of the variables of interest around the event
# event_df: must be the returned dataframe from summarize_around_event
# x_lab: label for x-axis
# y_max: max value of y-axis
# var_names: not applicable at the moment
plot_event <- function(event_df, x_lab = NULL, y_max = 2) {
  
    event_df %>% 
    filter(index >=0 ) %>% 
    pivot_longer(!index) %>% 
    ggplot(aes(index, value, col=name, linetype=name)) + 
    geom_line() +
    geom_vline(xintercept = 0, col ="grey") +
    geom_hline(yintercept = 0, col = "grey") + 
    scale_y_continuous(limits = c(-y_max, y_max)) +
    labs(x = x_lab, y = NULL) +
    theme(aspect.ratio = 0.8)
}

```

```{r event-study-1, include=F, eval=F, fig.cap="Dynamics around peaks and troughs", fig.asp = 1.2}
(data_leads_lags %>% 
  summarize_around_event(., peak_Credit == 1L, c("GDP", "CPI")) %>% 
  plot_event(., "Quarters after credit peak",1)  
) +
(data_leads_lags %>% 
  summarize_around_event(., trough_Credit == 1L, c("GDP", "CPI")) %>% 
  plot_event(., "Quarters after credit trough",1)  
) +
(data_leads_lags %>% 
  summarize_around_event(., peak_House == 1L, c("GDP", "CPI")) %>% 
  plot_event(., "Quarters after real estate peak", 1)
)  +
(data_leads_lags %>% 
  summarize_around_event(., trough_House == 1L, c("GDP", "CPI")) %>% 
  plot_event(., "Quarters after real estate trough", 1)
) +   
(data_leads_lags %>% 
  summarize_around_event(., peak_Leverage == 1L, c("GDP", "CPI")) %>% 
  plot_event(., "Quarters after leverage cycle peak", 2)
)  +
(data_leads_lags %>% 
  summarize_around_event(., trough_Leverage == 1L, c("GDP", "CPI")) %>% 
  plot_event(., "Quarters after leverage cycle trough", 2)
) + 
plot_layout(ncol = 2, guides = "collect")
```

```{r event-study-2, fig.cap="Real GDP dynamics around financial cycle peaks and troughs", fig.asp = 1.2}
(summarize_around_event(data_leads_lags, peak_Credit == 1L, "GDP") %>% 
  left_join(placebo_event(data_leads_lags, "GDP"), by = "index") %>% 
  plot_event(., "Quarters after credit peak", 1)
) +
(summarize_around_event(data_leads_lags, trough_Credit == 1L, "GDP") %>% 
  left_join(placebo_event(data_leads_lags, "GDP"), by = "index") %>% 
  plot_event(., "Quarters after credit trough", 1)
) +
(summarize_around_event(data_leads_lags, peak_House == 1L, "GDP") %>% 
  left_join(placebo_event(data_leads_lags, "GDP"), by = "index") %>% 
  plot_event(., "Quarters after real estate peak", 1)
) +
  (summarize_around_event(data_leads_lags, trough_House == 1L, "GDP") %>% 
  left_join(placebo_event(data_leads_lags, "GDP"), by = "index") %>% 
  plot_event(., "Quarters after teal estate trough", 1)
) +
  (summarize_around_event(data_leads_lags, peak_Leverage == 1L, "GDP") %>% 
  left_join(placebo_event(data_leads_lags, "GDP"), by = "index") %>% 
  plot_event(., "Quarters after leverage cycle peak", 2)
) +
  (summarize_around_event(data_leads_lags, trough_Leverage == 1L, "GDP") %>% 
  left_join(placebo_event(data_leads_lags, "GDP"), by = "index") %>% 
  plot_event(., "Quarters after leverage cycle trough", 2)
) +
plot_layout(ncol = 2, guides = "collect")
```


# Financial cycles and business cycles {#regress}

## Local projection

$$ y_{t+h}=\mu_h + \delta_h\text{PEAK}_t + \Phi(L)X_t +\epsilon_{t+h} $$

```{r regression-helpers}
# Run a batch of regressions and return a list of lm results
# formulas: a vector of string formulas to run
# data: the data frame passed on to lm
batch_run_regress <- function(formulas, data) {
  formulas %>% map(~ lm(., data))
}

# Extract the coefficient of a certain regressor from a batch of regressions
# lmfits: a list of lm result
# coef: the variable of interest in the regressors
batch_extract_coef <- function(lmfits, coef) {
  coef <- enquo(coef)
  lmfits %>% imap_dfr(function(fit, i) {
    tidy(fit) %>% 
      filter(term == quo_name(coef)) %>% 
      mutate(index = i) %>% 
      select(index, estimate) %>% 
      rename(!!coef := estimate) 
  })
}

# summarize a batch of lm results into a single table
# coef: a list of coefficients to keep in the output table
#       e.g. list('Print-friendly name' = 'Original name') 
# add_rows: a list of additional rows to add to the output table
#           e.g. list(Controls = "Yes")
# vcov: variance-covariance matrix; if null, robust SE is computed
batch_summarize <- function(lmfits, coefs, add_rows = NULL, vcov = NULL) {
  lmfits %>% imap(function(fit, index) {
    label <- as.symbol(sprintf("(%d)", index))
    tidy(coeftest(fit, vcovHAC)) %>% 
      filter(term %in% names(coefs)) %>% 
      mutate(term = as.character(coefs[term])) %>% 
      mutate(!!label := sprintf("%.3f (%.3f)", estimate, p.value)) %>%  
      select(term, !!label) %>% 
      add_row(term = names(add_rows), !!label := as.character(add_rows)) %>% 
      add_row(term = "$R^2$", !!label := glance(fit) %>% pull(r.squared) %>% format(digits=3)) 
      # add_row(term = "N", !!label := glance(fit) %>% pull(nobs) %>% format()) 
  }) %>% reduce(~full_join(.x,.y, by='term'))
}

# helpers to create formula strings with lags
# I: converts a single symbol to string
# L: creates lagged variables
# H: creates leaded variables
I <- function(x) paste(quo_name(enquo(x)))
L <- function(x, n) paste(sprintf("L%d_%s", n, quo_name(enquo(x))), collapse = "+")
H <- function(x, n) paste(sprintf("H%d_%s", n, quo_name(enquo(x))), collapse = NULL)
# creates regression equation (in string)
# note this returns a vector of strings when lhs is a vector
EQ <- function(lhs, rhs) sprintf("%s ~ %s", lhs, str_c(rhs, collapse = "+"))
```

```{r run-local-projection}
lmfit_credit_peak <- 
  EQ(lhs = H(GDP, 1:6), rhs = c(I(peak_Credit), L(GDP, 0:2), L(CPI, 0:2), L(IR, 0:2))) %>% 
  batch_run_regress(., data = data_leads_lags)

lmfit_credit_trough <- 
  EQ(lhs = H(GDP, 1:6), rhs = c(I(trough_Credit), L(GDP, 0:2), L(CPI, 0:2), L(IR, 0:2))) %>% 
  batch_run_regress(., data = data_leads_lags)

lmfit_house_peak <- 
  EQ(lhs = H(GDP, 1:6), rhs = c(I(peak_House), L(GDP, 0:2), L(CPI, 0:2), L(IR, 0:2))) %>% 
  batch_run_regress(., data = data_leads_lags)

lmfit_house_trough <- 
  EQ(lhs = H(GDP, 1:6), rhs = c(I(trough_House), L(GDP, 0:2), L(CPI, 0:2), L(IR, 0:2))) %>% 
  batch_run_regress(., data = data_leads_lags)

lmfit_leverage_peak <- 
  EQ(lhs = H(GDP, 1:6), rhs = c(I(peak_Leverage), L(GDP, 0:2), L(CPI, 0:2), L(IR, 0:2))) %>% 
  batch_run_regress(., data = data_leads_lags)

lmfit_leverage_trough <- 
  EQ(lhs = H(GDP, 1:6), rhs = c(I(trough_Leverage), L(GDP, 0:2), L(CPI, 0:2), L(IR, 0:2))) %>% 
  batch_run_regress(., data = data_leads_lags)
```




```{r stargazer, include=FALSE}
# # stargazer is a great package, but I don't use it this time
# do.call(stargazer, args = c(
#   lmfit_credit_peak,
#   lmfit_credit_trough,
#   list(
#     #type = "text",
#     type = "latex",
#     label = "tab-credit-peak",
#     title = "Local projection",
#     keep = c("Constant", "Credit"),
#     dep.var.caption = "",
#     #dep.var.labels.include = F,
#     dep.var.labels = c(str_c("h=", 1:6), str_c("h=", 1:6)),
#     covariate.labels = c("PEAK", "TROUGH", rep(NA, 10)),
#     omit.stat = c("adj.rsq", "ser", "f")
#   )
# ))
```


```{r produce-lp-table}
tbl_credit <- 
  c(lmfit_credit_peak, lmfit_credit_trough) %>% 
  batch_summarize(., coefs = list(
    #'(Intercept)' = '$\\mu$', 
    'peak_Credit' = '$\\delta^{(P)}$', 
    'trough_Credit' = '$\\delta^{(T)}$'
  )) %>% slice(1,3,2) 

tbl_house <- 
  c(lmfit_house_peak, lmfit_house_trough) %>% 
  batch_summarize(., coefs = list(
    'peak_House' = '$\\delta^{(P)}$', 
    'trough_House' = '$\\delta^{(T)}$'
  )) %>% slice(1,3,2) 

tbl_leverage <- 
  c(lmfit_leverage_peak, lmfit_leverage_trough) %>% 
  batch_summarize(., coefs = list(
    'peak_Leverage' = '$\\delta^{(P)}$', 
    'trough_Leverage' = '$\\delta^{(T)}$'
  )) %>% slice(1,3,2) 

bind_rows(tbl_credit, tbl_leverage, tbl_house) %>% 
  kbl(booktabs = T, escape = F,
      label = "tab-gdp-after-peak-trough",
      caption = "Real business cycle dynamics after financial cycle peaks/troughs",
      col.names = c(" ", str_c("h=",1:6), str_c("h=",1:6))) %>% 
  pack_rows("Credit cycle", 1,3, hline_after = T) %>%
  pack_rows("Leverage cycle", 4,6, hline_after = T) %>%
  pack_rows("Real estate cycle", 7,9, hline_after = T) %>%
  add_header_above(c(" ", "Quarters after peak"=6, "Quaters after trough"=6)) %>% 
  add_header_above(c(" ", "Dependent variable: 100 \\times log GDP gap"=12)) %>% 
  footnote(general = paste0("Standard errors are heteroskedasticity and ",
                            "autocorrelation consistent. $p$-values are ", 
                            "reported in parentheses."), escape = F) %>% 
  kable_styling(full_width = T) %>% 
  landscape()
```


## Bayesian VAR

This section employs a VAR model to elicit the inter-relationship between the
variables of interest. The reduced-form of the model is as following

\begin{equation}
y_t = c + \sum_{j=1}^{p} \Phi_j y_{t-j} + u_t 
\label{eq:var-model}
\end{equation}

where 

\begin{equation}
y_t = [ 
  \text{GDP}_t, 
  \text{CPI}_t, 
  \text{IR}_t, 
  \text{Credit}_t, 
  \text{Credit/GDP}_t, 
  \text{House}_t 
  ] 
\label{eq:vars}
\end{equation}

All the variables included here are stationary (see Annex \ref{annex-unit-root}
for unit root test). Considering the limited size of the data, I estimate the
model with Bayesian method to avoid the "curse of dimensionality". I adopt the
Minnesota prior and set the prior AR(1) coefficient to zero. ^[Other parameters
of the Minnesota prior are left with standard settings: $\\lambda\_1=0.2$
(overall tightness), $\\lambda\_2=1$ (relative cross-variable weight),
$\\lambda\_3=1$ (lag decay).] To identify the structural shocks, Cholesky
decomposition is applied to the residuals with regard to the ordering of
variables as in Equation (\ref{eq:vars}). ^[This ordering is justified as
follows: the ordering of output, price level and interest rate follows directly
from standard IS/LM models, in which output responses to price level only with
lags, and central banks set interest rate in response to both output and price
level. It is reasonable to expect credit follows interest rate, not the other
way around. And credit fuels the purchasing of real estate. However, the results
are robust to different ordering the variables. Annex \ref{annex-ordering}
tests the sensitivity of the impulse responses to different ordering.]

The impulse responses of all variables are provided in Annex
\ref{annex-impulse}. I focus here on response of real variables to proxies of
financial cycles. Figure \ref{fig:imp-gdp} shows the (accumulated) impulse
response of GDP to innovations in credit, credit to GDP ratio, and housing
price. It shows that an unexpected increase in all three variables leads to
increase of real output, with housing price the most prominent. The up trend
peaks after roughly 10 quarters, then the trend starts to reverse. This suggests
a financial expansion presages an immediate bump up in real output, and then a
subsequent decline.

```{r imp-gdp, fig.cap="Impulse response of GDP to innovations", out.width="49%", fig.show="hold"}
knitr::include_graphics(c("graph/imp_gdp.pdf", "graph/imp_gdp_acc.pdf"))
```

Figure \ref{fig:imp-cpi} shows the response of price level, measured by CPI, to
an unexpected upward movement of financial cycle. Price level responds
positively to all three innovations, but price is much more sensitive to credit
shocks than output. The up-moving trend of the price level peaks in 9 quarters
after a positive credit shock. The rising house price has more enduring impact
on price level -- the upward movement lasts for 12 quarters before its reversal.

```{r imp-cpi, fig.cap="Impulse response of CPI to innovations", out.width="49%", fig.show="hold"}
knitr::include_graphics(c("graph/imp_cpi.pdf", "graph/imp_cpi_acc.pdf"))
```

Why the business cycle reverses its trend in two and a half years after a
financial expansion? The response of interest rate to financial cycle might shed
some light. As shown in Figure \ref{fig:imp-ir}, upward movement of credit or
housing price elicits rise in interest rate. The response of interest rate is
especially aggressive to rising housing price. The rising interest rate tightens
financial conditions and curbs real economic activities. This possibly explains
the reversal of the business cycle after a short-run expansion.

```{r imp-ir, fig.cap="Impulse response of interest rate to innovations", out.width="49%", fig.show="hold"}
knitr::include_graphics(c("graph/imp_ir.pdf", "graph/imp_ir_acc.pdf"))
```


Based on the orthogonalised shocks, one can calculate the contributions of each
shocks to the development of economic process. This may help understand the role
of financial factors in shaping business cycles. Figure \ref{fig:hd-gdp}
decomposes the historical cycles of GDP and CPI into different shocks. A full
list of historical decomposition can be found in Annex \ref{annex-hd-full}.

```{r hd-gdp, fig.cap="Historical decomposition", out.width="49%", fig.show="hold"}
knitr::include_graphics(c("graph/hd_gdp.pdf", "graph/hd_cpi.pdf"))
```

As shown in Figure \ref{fig:hd-gdp}, real GDP cycles are mostly contributed by
shocks to itself and shocks to CPI. Credit shocks played an important role
during before and during the GFC. The importance of credit gradually moderated
after the GFC. An exception is the year of 2012, in which credit shocks again
played a prominent role. This was a period when China's financial sector
undertook "innovations" to circumvent regulations.

House price historically played a prominent role in affecting the business
cycle. A notable feature is that house price tends to play a supportive role
when China's GDP swings below the growth trend. This can be explained by that
China's authority typically relax the policies that restrict home purchase to
counter economic downturn pressure. For example, during the economic downturn
in 2014, most cities remove the limits on the number of homes one can buy. The
importance of house price attenuated since 2016, as the authority adopted the
"long-term mechanism" for real estate regulation.


# Discussion

The last section in the document will be used as the section title for the bibliography.


\cleardoublepage

# References {-}

<div id="refs"></div>

